# -*- coding: utf-8 -*-
from __future__ import absolute_import
from __future__ import unicode_literals

import base64
import binascii
import warnings

from django.contrib.contenttypes import generic
from django.contrib.contenttypes.models import ContentType
from django.core import validators
from django.core.exceptions import ValidationError
from django.db import models
from django.dispatch import receiver

from gridplatform.trackuser import get_user

from . import fields
from . import get_encryption_context
from .conf import settings
from .managers import DecryptingManager
from .signals import encryption_key_created
from .base import get_cipher_module


class EncryptedModel(models.Model):
    """
    The :class:`.EncryptedModel` is a :class:`.Model` class that allows for
    some of its fields to be encrypted; that is, if they subclass
    :class:`.EncryptedField`.  Normal fields can be used together with
    encrypted fields.  These will never be encrypted though, and will otherwise
    work as they do on normal :class:`Models<.Model>`.

    Any :class:`.EncryptedField`, ``field``, will appear as multiple member
    variables on the :class:`.EncryptedModel` ``model``: ``model.field`` and
    ``model.field_plain``.  ``model.field`` holds the encrypted field value if
    available and ``model.field_plain`` holds the decrypted field value if
    available.  See :class:`.EncryptedField` for the details.

    :class:`.EncryptedModel` works well with :class:`Forms<.Form>`.

    An `EncryptedModel` can be decrypted using the
    :meth:`.EncryptedModel._decrypt` method and encrypted using the
    :meth:`.EncryptedModel._encrypt()` method.  This happens automatically upon
    loading from the data base and on saving, given an encryption context is
    available.

    Setting a decrypted field will clear the corresponding encrypted field and
    vice versa.

    :ivar encryption_data_initialization_vector: An encryption data
        initialization vector.  This is generated by the
        :meth:`.EncryptionContext.generate_iv`, and used to construct the
        cipher (see :meth:`.EncryptionContext.get_cipher`).

    :cvar objects: The default manager for :class:`.EncryptedModel` is
        :class:`.DecryptingManager`.
    """

    encryption_data_initialization_vector = fields.Base64Field(editable=False)

    objects = DecryptingManager()

    class Meta:
        abstract = True

    def __init__(self, *args, **kwargs):
        """
        Construct a new :class:`.EncryptedModel` such that encrypted fields,
        ``field``, may have their plain text members instantiated through
        ``field_plain`` keyword arguments.
        """
        encrypted_fields = [
            f for f in self._meta.fields
            if isinstance(f, fields.EncryptedField)
        ]
        plain = {}
        for field in encrypted_fields:
            plain_name = field._plain_property
            if plain_name in kwargs:
                plain[plain_name] = kwargs.pop(plain_name)

        super(EncryptedModel, self).__init__(*args, **kwargs)
        if not self.pk:
            # New object...
            for field in encrypted_fields:
                val = getattr(self, field._ciphertext_attribute)
                if val != '':
                    warnings.warn(
                        'Ciphertext value provided for field \'{}\' on new '
                        '(no-pk) {} object -- error in unit test?'.format(
                            field.name, self.__class__.__name__),
                        stacklevel=2)
                    warnings.warn(
                        'Ciphertext value provided for field \'{}\' on new '
                        '(no-pk) {} object -- error in unit test?.'.format(
                            field.name, self.__class__.__name__),
                        stacklevel=3)
                # NOTE: setting plaintext anyway --- plaintext for blank allows
                # create-forms to omit the field without weird SQL errors; the
                # other case is a workaround for models that are "sometimes
                # encrypted" and for unit tests that intend to use an identity
                # cipher but initialise the ciphertext member...
                setattr(self, field._plaintext_attribute, val)
        elif get_encryption_context() is not None:
            self._decrypt(get_encryption_context())
        for plain_name, plain_value in plain.iteritems():
            setattr(self, plain_name, plain_value)

    def save(self, *args, **kwargs):
        """
        Lazily encrypt self and then delegate save to parent model
        """
        encrypted_fields = [
            f for f in self._meta.fields
            if isinstance(f, fields.EncryptedField)
        ]
        if any([getattr(self, f._plain_property) is not None and
                getattr(self, f._cipher_property) is None
                for f in encrypted_fields]):
            self._encrypt(get_encryption_context())
        super(EncryptedModel, self).save(*args, **kwargs)

    def __repr__(self):
        # NOTE: EncryptedModels are very likely to include encrypted fields in
        # their unicode, which leads to a crash when inspected via repr from
        # shell.
        return '<%s(id=%s)>' % (self.__class__.__name__, self.id)

    def __reduce__(self):
        """
        Sanity check for pickling --- disallow/fail if encrypted data present.
        """
        encrypted_fields = [
            f for f in self._meta.fields
            if isinstance(f, fields.EncryptedField)
        ]
        if any([getattr(self, f._plain_property) for f in encrypted_fields]):
            raise ValueError(b'Pickling disallowed for decrypted objects.')
        return super(EncryptedModel, self).__reduce__()

    def _encrypt(self, encryption_context):
        """
        Encrypt data for :class:`.EncryptedField` fields of this instance.

        :param encryption_context: The :class:`.EncryptionContext` to use for
            encryption.
        """
        if encryption_context is None:
            if settings.ENCRYPTION_TESTMODE:
                warnings.warn(
                    'Cannot encrypt; missing encryption context.',
                    stacklevel=3)
                return
            raise ValueError('Cannot encrypt; missing encryption context.')

        key_id = self.get_encryption_id()
        assert key_id is not None
        model, pk = key_id
        assert pk is not None, \
            '{}.get_encryption_id() must return (modelclass, integer), ' \
            'returned {}'.format(self.__class__, repr(key_id))

        iv = encryption_context.generate_iv()
        self.encryption_data_initialization_vector = bytearray(iv)
        cipher = encryption_context.get_cipher(key_id, iv)

        encrypted_fields = [
            f for f in self._meta.fields
            if isinstance(f, fields.EncryptedField)
        ]
        for field in encrypted_fields:
            plaintext = getattr(self, field._plaintext_attribute)
            if plaintext is None:
                raise AttributeError(
                    'Missing data for encryption: No plaintext data in '
                    '\'{}\''.format(field._plaintext_attribute))
            ciphertext = cipher.encrypt(plaintext.encode('utf-8'))
            encoded = base64.encodestring(ciphertext)
            setattr(self, field._ciphertext_attribute, encoded)

    def _decrypt(self, encryption_context):
        """
        Decrypt data for :class:`.EncryptedField` fields on this instance.

        :param encryption_context: The :class:`.EncryptionContext` to use for
            encryption.
        """
        if encryption_context is None:
            if not get_user() is None:
                warnings.warn(
                    'Cannot decrypt; missing encryption context.',
                    stacklevel=3)
            return
        key_id = self.get_encryption_id()
        if key_id is None:
            warnings.warn(
                'Cannot decrypt; object missing encryption ID.',
                stacklevel=3)
            return
        iv = str(self.encryption_data_initialization_vector)
        if not iv:
            iv = '\0' * 16
        cipher = encryption_context.get_cipher(key_id, iv)

        encrypted_fields = [
            f for f in self._meta.fields
            if isinstance(f, fields.EncryptedField)
        ]
        try:
            for field in encrypted_fields:
                encoded = getattr(self, field._ciphertext_attribute)
                if encoded is None:
                    raise AttributeError('Missing data for decryption')
                try:
                    ciphertext = base64.decodestring(encoded)
                except (UnicodeEncodeError, binascii.Error):
                    warnings.warn(
                        'Ciphertext was invalid base64 -- '
                        'using ciphertext as plaintext ({}).'.format(
                            self.__class__.__name__))
                    plaintext = encoded
                else:
                    plaintext_bytes = cipher.decrypt(ciphertext)
                    plaintext = plaintext_bytes.decode('utf-8')
                setattr(self, field._plaintext_attribute, plaintext)
        except UnicodeDecodeError:
            warnings.warn(
                'Output from decryption was invalid utf-8 -- '
                'wrong cipher/error in unit test ({})?'.format(
                    self.__class__.__name__))
            for field in encrypted_fields:
                self._plaintext_attribute = None

    def reset_encryption(self):
        """
        Reinitializes ``self.encryption_data_initialization_vector`` and clears all
        encrypted fields.
        """
        self.encryption_data_initialization_vector = \
            get_cipher_module().generate_iv()
        for field in self._meta.fields:
            attname, column = field.get_attname_column()
            plain_name = '_{}_plain'.format(column)
            if hasattr(self, plain_name):
                setattr(self, attname, '')
                setattr(self, plain_name, '')

    def get_encryption_id(self):
        """
        Return identity of the encryption key used to
        :meth:`.EncryptedModel._encrypt` and :meth:`.EncryptedModel._decrypt`
        this instance.  Subclasses should implement this method.

        By convention the encryption key identity (encryption id) is a
        tuple of the owning EncryptionModel specialization and the
        primary key of the owner, for example::

            return (Customer, self.customer_id)

        We have this convention because:

          - we don't want to force loading of the concrete objects
            from the DB (the encryption "owner" ID can often be read
            from the foreign key of the object to be
            encrypted/decrypted)

          - we *do* want to ensure that only objects with an ID
            assigned can be used, we don't want to involve object
            state apart from identity; hence this pair rather than the
            concrete model objects with that class and ID.

        :return: Returns identity of encryption key, e.g.::
                return (OwnerModelClass, owner_id)

        :raise NotImplementedError: This exception is raised when a subclass
            failed to reimplement this method.
        """
        raise NotImplementedError("Subclasses must implement this method")

    def clean_fields(self, exclude=None):
        """
        Cleans all fields and raises a :class:`.ValidationError` containing
        message_dict of all validation errors if any occur.

        Overridden for :class:`.EncryptedField` support.
        """
        if exclude is None:
            exclude = []

        errors = {}
        for f in self._meta.fields:
            if f.name in exclude:
                continue
            # difference from base: using f._plain_property for EncryptedField;
            # rather than f.attname always
            if isinstance(f, fields.EncryptedField):
                attname = f._plain_property
            else:
                attname = f.attname
            # Skip validation for empty fields with blank=True. The developer
            # is responsible for making sure they have a valid value.
            raw_value = getattr(self, attname)
            if f.blank and raw_value in validators.EMPTY_VALUES:
                continue
            try:
                setattr(self, attname, f.clean(raw_value, self))
            except ValidationError, e:
                errors[f.name] = e.messages

        if errors:
            raise ValidationError(errors)


class EncryptionUser(models.Model):
    """
    Mixes encryption user fields and methods into a user model.

    :ivar encryption_public_key: Public key for encrypting stuff that the mixed
        user may read.
    :ivar encryption_private_key: Private key for decrypting stuff that the
        mixed user may read (this is of course an encrypted version of the private
        key).
    :ivar encryption_key_initialization_vector: The encryption key
        initialization vector used to encrypt ``self.encryption_private_key``.
    """
    encryption_public_key = fields.Base64Field()
    encryption_private_key = fields.Base64Field()
    encryption_key_initialization_vector = fields.Base64Field()

    class Meta:
        abstract = True

    def generate_private_key(self, password, save=False):
        """
        Construct the private key for the user.
        """
        cipher_module = get_cipher_module()
        # generate new private/public keypair
        private_key, public_key = \
            cipher_module.generate_private_public_keypair()
        # set up for encryption of the private key:
        # get initialisation vector
        iv = cipher_module.generate_iv()
        # hash password to fixed length for AES key
        password_hash = cipher_module.hash_symmetric_key(password)
        # initialise cipher and encrypt the private key
        cipher = cipher_module.symmetric_cipher(password_hash, iv)
        private_key_ciphertext = cipher.encrypt(private_key)
        # store initialisation vector, public key and encrypted private key
        self.encryption_key_initialization_vector = bytearray(iv)
        self.encryption_public_key = bytearray(public_key)
        self.encryption_private_key = bytearray(private_key_ciphertext)
        if save:
            self.save()

    def update_private_key(self, old_password, new_password, save=False):
        """
        Update the encryption of a users private key, from using the old to the
        new password.
        """
        cipher_module = get_cipher_module()
        # read current initialisation vector and encrypted private key
        old_iv = str(self.encryption_key_initialization_vector)
        old_ciphertext = str(self.encryption_private_key)
        # hash old password to fixed length for AES key
        old_password_hash = cipher_module.hash_symmetric_key(old_password)
        # make cipher to decrypt currently stored private key, decrypt it
        decrypt_cipher = \
            cipher_module.symmetric_cipher(old_password_hash, old_iv)
        plaintext = decrypt_cipher.decrypt(old_ciphertext)
        # NOTE: try to import the key as a sanity check only;
        cipher_module.load_private_key(plaintext)
        # now, we will reencrypt with a key based on the new password
        # generate new initialisation vector
        iv = cipher_module.generate_iv()
        # hash new password to fixed length for AES key
        new_password_hash = cipher_module.hash_symmetric_key(new_password)
        # make new cipher to encrypt private, encrypt it
        cipher = cipher_module.symmetric_cipher(new_password_hash, iv)
        ciphertext = cipher.encrypt(plaintext)
        # store new initialisation vector, reencrypted private key
        self.encryption_key_initialization_vector = bytearray(iv)
        self.encryption_private_key = bytearray(ciphertext)
        if save:
            self.save()

    def grant_key(self, key_id, plaintext):
        """
        Grant someone elses private key to this user.

        :param key_id: The identity (encryption id) of the owner of the private
            key.
        :param plaintext:  The private key in plaintext.

        The given private key will be stored encrypted in
        ``self.encryptionkey_set``.  The encryption will happen using this
        users public key.
        """
        cipher_module = get_cipher_module()
        public_key = cipher_module.load_public_key(
            str(self.encryption_public_key))
        # Initialize cipher based on users public key, encrypt the secret.
        # This is the only place we use private/public keys --- for exactly
        # this use; being able to give secret data to another user without
        # knowing their private decryption code...
        cipher = cipher_module.public_key_cipher(public_key)
        ciphertext = cipher.encrypt(plaintext)
        model_class, object_id = key_id
        content_type = ContentType.objects.get_for_model(model_class)
        # Only create key if key with same ID does not already exist for user.
        self.encryptionkey_set.get_or_create(
            content_type=content_type, object_id=object_id,
            defaults={'key': bytearray(ciphertext)})

    def decrypt_private_key(self, password):
        """
        Decrypt private key for user logging in.
        """
        cipher_module = get_cipher_module()
        # read initialisation vector
        iv = str(self.encryption_key_initialization_vector)
        # hash password to fixed length for AES key
        password_hash = cipher_module.hash_symmetric_key(password)
        # initialise cipher to decrypt private key
        cipher = cipher_module.symmetric_cipher(password_hash, iv)
        # read private key, decrypt it and initialise RSA key...
        ciphertext = str(self.encryption_private_key)
        return cipher.decrypt(ciphertext)

    def decrypt_keys(self, private_key):
        """
        Decrypt encryption keys for the current user and set them as attribute
        'encryption_context' on the request.
        """
        cipher_module = get_cipher_module()
        # initialise new/other cipher with the RSA key
        rsa_key = cipher_module.load_private_key(private_key)
        cipher = cipher_module.private_key_cipher(rsa_key)
        # decrypt all of the per-customer/per-? keys accessible to this user,
        # using the cipher with the RSA key
        encryption_context = {
            elem.key_id(): cipher.decrypt(str(elem.key))
            for elem in self.encryptionkey_set.all()
        }
        return encryption_context


class BaseEncryptionKey(models.Model):
    """
    Abstract base model for storing private keys shared with a trusted entity
    by a foreign entity.

    :ivar key: The private key of the foreign entity, encrypted using the
        public key of the trusted entity.
    :ivar content_type: The
        :class:`django.contrib.contenttypes.models.ContentType` of the foreign
        entity.
    :ivar object_id:  The primary key of the foreign entity.
    :ivar content_object: A :class:`.GenericForeignKey` to the foreign entity
        whose private key is being held.
    """
    key = fields.Base64Field()
    content_type = models.ForeignKey(
        'contenttypes.ContentType', on_delete=models.PROTECT)
    object_id = models.PositiveIntegerField()
    content_object = generic.GenericForeignKey('content_type', 'object_id')

    class Meta:
        abstract = True

    def key_id(self):
        """
        :return: The encryption ID of the foreign entity.
        """
        content_type = ContentType.objects.get_for_id(self.content_type_id)
        return (content_type.model_class(), self.object_id)

    @classmethod
    def generate(cls, key_id):
        """
        Generate a new encryption key, and grant access to the current
        logged-in user.
        """
        if settings.ENCRYPTION_TESTMODE:
            return

        model_class, object_id = key_id
        key = get_cipher_module().generate_symmetric_key()

        encryption_key_created.send(sender=model_class, key=key, key_id=key_id)

    @classmethod
    def share(cls, key_id, user):
        """
        Grant a user access to an element from an encryption context.  This may
        be used to share access available to the current user with another
        user.
        """
        if settings.ENCRYPTION_TESTMODE:
            return

        encryption_context = get_encryption_context()
        key = encryption_context.keys[key_id]
        user.grant_key(key_id, key)


class EncryptionKey(BaseEncryptionKey):
    """
    :class:`.BaseEncryptionKey` specialization where the trusted entity is a
    :class:`auth.User`.

    :ivar user:  The user that is the trusted entity.
    """
    user = models.ForeignKey('auth.User', on_delete=models.CASCADE)


@receiver(encryption_key_created)
def auto_grant_to_current_user(sender, key, key_id, **kwargs):
    """
    Grant any created encryption keys to the current active user when the key
    was/is created.
    """
    user = get_user()
    encryption_context = get_encryption_context()
    if user is None:
        warnings.warn('No "current user"; will not grant key')
    else:
        user.grant_key(key_id, key)
    if encryption_context is None:
        warnings.warn('No "current encryption context"; cannot add key')
    elif key_id in encryption_context.keys:
        raise ValueError(
            'Key with given ID already exists in encryption context')
    else:
        encryption_context.keys[key_id] = key
